# PR作成・レビューフェーズ

## 4️⃣ PR作成・レビューフェーズ

### 📤 PR作成ワークフロー

**🚨 CRITICAL: PR作成は必須**

- ❌ **mainブランチへの直接push・コミットは絶対禁止**
- ✅ **すべての変更は必ずPRを経由してmainにマージ**
- ✅ PRが承認・マージされるまでIssueはIn Progressのまま

**自動化されたフロー:**

1. **フィーチャーブランチにpush後**: PRを作成
2. **追加のpush時**: PR本文を自動更新（必要に応じて）
3. **レビュー依頼**: 必要に応じてレビュアーを指定
4. **PR承認後**: mainにマージ
5. **マージ後のみ**: IssueをDoneに変更（Jira側でPRマージと連動するため、手動での変更は不要）

**PR作成前チェック:**

- [ ] 現在のブランチがmainではないことを確認（`git branch`）
- [ ] すべての変更がコミット済み
- [ ] push前のローカルチェックを完了（lint/test/e2e）
- [ ] テストが通ることを確認
- [ ] コンフリクトが発生していないか確認

**参照ルール:**

- **`.cursor/rules/03-git-workflow.d/04-pr-review.md`** - PR作成・レビュー対応

### 🔍 CI確認と対応

**PR作成後の自動確認:**

1. CIステータスの確認（30-60秒待機後）
2. エラー発生時の原因究明
3. 自分の修正によるエラー → 即座に修正
4. 既存のエラー → Issue作成

**参照ルール:**

- **`.cursor/rules/03-git-workflow.d/04-pr-review.md`** - CI確認・エラー対応

### 🤖 Gemini Code Assistレビュー対応

**🚨 CRITICAL: レビュー対応の絶対ルール**

- [ ] すべての指摘に必ず対応する（見落とし禁止）
- [ ] 1つの指摘に対して、1 commitで対応する
- [ ] すべての指摘対応完了後、PRコメントで返信する
- [ ] 関連するIssueにもコメントする（必須）

#### レビューコメント確認手順

1. **レビューコメントの取得**
   ```bash
   # PRのレビューコメントを確認
   gh pr view <PR_NUMBER> --json reviews --jq '.reviews[] | select(.author.login == "gemini-code-assist") | .body'
   
   # ファイルごとのコメントを確認
   gh api repos/<OWNER>/<REPO>/pulls/<PR_NUMBER>/comments --jq '.[] | select(.user.login == "gemini-code-assist")'
   ```

2. **指摘事項の整理**
   - レビューコメントを読み、指摘事項をリスト化
   - 各指摘の重要度と対応優先順位を決定
   - ToDoリストを作成（`todo_write`ツールを使用）

3. **対応方針の決定**
   - 各指摘に対して対応方法を検討
   - 必要に応じて、設計変更やリファクタリングを検討
   - 対応順序を決定

#### レビュー対応のベストプラクティス

**1. ToDoリストの作成**
- レビューコメントを確認後、まずToDoリストを作成
- 各指摘を個別のタスクとして管理
- 対応順序を明確にする

**2. 段階的な対応**
- 1つの指摘に対して、1つのコミットで対応
- 複数の指摘がある場合は、順番に対応
- 各対応後に動作確認を実施

**3. コミットメッセージ**
- 指摘内容を明確に記載
- 対応内容を簡潔に説明
- 例: `fix: Geminiレビュー指摘に対応 - 設定の重複問題を解決`

**4. 対応完了後の確認**
- すべての指摘に対応したことを確認
- 動作確認を実施
- PRコメントで対応内容を報告

**5. PRコメントでの返信**
- 各指摘に対する対応内容を説明
- 対応したコミットへのリンクを記載
- 必要に応じて、対応しなかった理由を説明

#### よくある指摘パターンと対応方法

**設定の重複**
- **指摘**: 複数の設定ファイルに同じ設定が存在
- **対応**: Single Source of Truthを確立し、設定を一元化

**ドキュメントの不足**
- **指摘**: 設定の優先順位や使用方法が不明確
- **対応**: ドキュメントに詳細な説明を追加

**コードの構造**
- **指摘**: コードの構造や設計に関する提案
- **対応**: 提案を検討し、必要に応じてリファクタリング

**条件分岐の簡略化**
- **指摘**: 同じパターンの条件分岐が繰り返されている
- **対応**: ヘルパー関数を作成して重複を削減
  ```bash
  # 悪い例: 同じパターンが繰り返される
  if [ -n "$value1" ] && [ "$value1" != "null" ] && [ -z "${VAR1:-}" ]; then
    VAR1="$value1"
  fi
  if [ -n "$value2" ] && [ "$value2" != "null" ] && [ -z "${VAR2:-}" ]; then
    VAR2="$value2"
  fi
  
  # 良い例: ヘルパー関数で統合
  set_config_if_unset() {
    local yaml_value="$1"
    local env_var_name="$2"
    if [ -n "$yaml_value" ] && [ "$yaml_value" != "null" ] && [ -z "${!env_var_name:-}" ]; then
      eval "$env_var_name=\"\$yaml_value\""
    fi
  }
  set_config_if_unset "$value1" "VAR1"
  set_config_if_unset "$value2" "VAR2"
  ```

**セキュリティ**
- **指摘**: セキュリティ上の懸念
- **対応**: 即座に対応し、セキュリティベストプラクティスに準拠
- **APIトークンの有効期限設定**
  - **指摘**: APIトークンの有効期限が「無期限」となっているのはセキュリティ上危険
  - **対応**: トークンには必ず有効期限を設定し（例: 90日）、定期的なローテーションを推奨する仕組みを導入
  - **理由**: トークンが漏洩した場合、手動で無効化されるまで無制限にアクセスされ続ける可能性がある
- **内部通信の認証強化**
  - **指摘**: 内部サービス間通信で認証を「なし」としているが、セキュリティの観点から懸念がある
  - **対応**: Defense in Depth（多層防御）の原則に基づき、内部通信にも認証を導入することを推奨（例: mTLS（mutual TLS）やサービス間でのJWTトークン交換）
  - **理由**: 万が一ネットワーク内部に侵入された場合でも、不正なサービス間通信を防ぐことができる
  - **注記**: ネットワークポリシーによるアクセス制御は重要だが、それだけに依存せず、多層防御を実現する
  - **本番環境での必須要件**: 通信プロトコル一覧表の備考欄でも「※本番環境ではmTLS必須」のように明記し、本番環境での認証を必須と位置づけるべき
- **プロトコル定義の正確性**
  - **指摘**: プロトコルの記載が不正確（例: Fluentd Forward Protocolが「HTTP/TCP」と記載されているが、実際はTCP上で動作する独自のバイナリプロトコル）
  - **対応**: プロトコルの正確な定義を確認し、ドキュメントを修正
  - **セキュリティ機能の推奨**: プロトコルがサポートしているセキュリティ機能（例: TLS暗号化、共有キー認証）を本番環境で利用することを推奨する旨を明記
- **認証方式の表現の明確性**
  - **指摘**: 認証方式が「なし（TLS証明書による暗号化）」と記載されているが、これは紛らわしい表現。TLS証明書は通信の暗号化とサーバーの認証を行うが、「認証方式」は通常ユーザー認証を指す
  - **対応**: ログイン前の画面アクセスではユーザー認証がないため、「なし」という表現の方が明確。「TLSによる暗号化」はプロトコルがHTTPSであることから自明
- **APIエンドポイントの正確性**
  - **指摘**: APIエンドポイントが誤っている（例: Jira APIで`search/jql`が指定されているが、正しくは`search`）
  - **対応**: APIドキュメントを確認し、正しいエンドポイントを使用する。`jira_api_call`関数などでベースURLが自動的に付与される場合は、エンドポイント部分のみを指定する

**アーキテクチャ図・Mermaid図のレビュー観点**

**セキュリティ境界図のレビュー観点**
- **指摘**: Mermaid図の凡例とコンポーネントのスタイリングが不一致
- **対応**:
  - 凡例の説明が図の実際のスタイリングと一致しているか確認
  - 図内のsubgraph名と凡例の説明が一致しているか確認
  - 色分けが適切に反映されているか確認
  - 例:
    ```markdown
    # ❌ 悪い例: 凡例と図が不一致
    凡例: 🟢 内部境界（アプリケーション層）
    図: subgraph "内部境界（DMZ相当）"
    
    # ✅ 良い例: 凡例と図が一致
    凡例: 🟢 内部境界（DMZ相当: 管理画面・API層）
    図: subgraph "内部境界（DMZ相当）"
    ```

- **指摘**: 内部境界セクション内の対象コンポーネントの列挙が不十分
- **対応**:
  - 対象コンポーネントを具体的に列挙する（「管理API ↔ バックエンドサービス」ではなく、個別のAPIとサービスを明記）
  - 通信の方向性を明確にする
  - 例:
    ```markdown
    # ❌ 悪い例: 抽象的
    - 管理API ↔ バックエンドサービス
    
    # ✅ 良い例: 具体的
    - **管理API ↔ バックエンドサービス**:
      - 設定管理API ↔ 設定管理サービス
      - ユーザー管理API ↔ ユーザー管理サービス
      - ログ取得API ↔ ログ管理サービス
    ```

- **指摘**: Redis通信の暗号化の説明が不十分（SSL/TLSが含まれていない）
- **対応**:
  - Redis通信についてもSSL/TLSによる暗号化を明記
  - パスワード認証だけでなく、通信の暗号化についても言及
  - 例:
    ```markdown
    # ❌ 悪い例: パスワード認証のみ
    - **Redis**: パスワード認証を推奨（本番環境では必須）
    
    # ✅ 良い例: SSL/TLS暗号化も含める
    - **Redis**: SSL/TLSによる通信の暗号化を推奨（本番環境では必須）、パスワード認証も推奨（本番環境では必須）
    ```

- **指摘**: 通信要件表で内部境界間の通信方法が不正確（HTTPではなくHTTPSを使用すべき）
- **対応**:
  - 内部境界間の通信もHTTPSを使用するように修正
  - mTLSはHTTPS上で実装されることを明確にする
  - 図と表の整合性を確認
  - 例:
    ```markdown
    # ❌ 悪い例: HTTP
    | 内部境界 → 内部境界 | HTTP | mTLS推奨 | mTLS推奨 |
    
    # ✅ 良い例: HTTPS
    | 内部境界 → 内部境界 | HTTPS | mTLS推奨 | TLS 1.2+ (mTLS推奨) |
    ```
- **コンポーネントの責務と接続先の整合性**
  - **指摘**: コンポーネントの責務と接続先が一致していない（例: ログ取得APIが設定管理サービスに接続されている）
  - **対応**: コンポーネントの責務を確認し、適切な接続先に修正
- **セクション番号の整合性**
  - **指摘**: セクション番号が重複している、または連番になっていない
  - **対応**: セクション番号を確認し、適切に修正
- **図の一貫性**
  - **指摘**: コンポーネント構成図と関係性図、シーケンス図で使用されているコンポーネント名が一致していない
  - **対応**: すべての図で同じコンポーネント名を使用するように統一
- **セキュリティ境界の明確化**
  - **指摘**: 内部通信が認証不要とされているが、ネットワークポリシーによる保護が前提である旨が明記されていない
  - **対応**: ネットワークポリシー（例: KubernetesのNetworkPolicy）による保護が前提である旨を明記
- **シーケンス図の参加者名の明確化**
  - **指摘**: シーケンス図の参加者名が曖昧で、どのコンポーネントを指しているか不明確
  - **対応**: コンポーネント構成図と一致する具体的な名称を使用（例: `認証サービス` → `ユーザー管理サービス(認証)`）
- **シーケンス図の参加者名の一貫性**
  - **指摘**: シーケンス図で抽象的な参加者名（例: `API as 管理API`、`Service as 設定管理サービス`）が使用されており、コンポーネント構成図（3.1.3.1）で定義されている具体的なコンポーネント名（例: `ConfigAPI`、`ConfigService`）と一致していない
  - **対応**: すべてのシーケンス図で、コンポーネント構成図で定義されている具体的なコンポーネント名を使用するように統一（例: `API as 管理API` → `ConfigAPI as 設定管理API`、`Service as 設定管理サービス` → `ConfigService as 設定管理サービス`、`API as 管理API` → `UserAPI as ユーザー管理API`）
  - **目的**: ドキュメント全体の整合性を保ち、将来の参照を容易にする
- **シーケンス図の自己参照の回避**
  - **指摘**: シーケンス図で自己参照（`LogServer->>LogServer`）が使用されており、処理の流れが不明確
  - **対応**: サブコンポーネント間のやり取りを表現するように修正（例: `LogCollector->>LogAnalyzer`）
- **バックエンドサービス層の明確化**
  - **指摘**: API層から直接ログ管理サーバなどの外部コンポーネントに接続されているが、バックエンドサービス層を経由すべき
  - **対応**: バックエンドサービス層に適切なサービスコンポーネントを追加し、API層はサービス層を経由して外部コンポーネントに接続するように修正（例: `LogAPI` → `LogService` → `LogAnalyzer`）
- **データフロー図の完全性**
  - **指摘**: 主要な機能（ログ取得など）のデータフロー図が不足している
  - **対応**: すべての主要な機能についてデータフロー図（シーケンス図）を追加
- **シーケンス図の参加者の正確性**
  - **指摘**: シーケンス図で抽象的な参加者名（例: `WAFエンジン`）が使用されているが、実際の処理主体（例: `ConfigAgent`）を明示すべき
  - **対応**: コンポーネント構成図と一致する具体的な参加者名を使用（例: `WAFエンジン` → `ConfigAgent`）
- **シーケンス図とコンポーネント構成図の整合性**
  - **指摘**: シーケンス図でコンポーネント間の直接連携が描かれているが、コンポーネント構成図（3.1.3.1）や責務定義（3.1.3.2）では中間コンポーネントを経由する設計になっている
  - **対応**: 
    - コンポーネント構成図で定義されている接続関係に合わせてシーケンス図を修正（例: `SigService` → `LogAnalyzer` ではなく `SigService` → `LogService` → `LogAnalyzer`）
    - 責務定義に基づいて、適切なサービス層を経由するように修正（例: `ConfigAPI` → `SigService` ではなく `ConfigAPI` → `ConfigService` → `SigService`）
    - すべてのコンポーネントが適切に表現されているか確認（例: `LogForwarder`が欠落していないか）

**ドキュメントの重複の回避**
- **指摘**: 複数のドキュメントで同じルールの記述が重複している
- **対応**: 
  - Single Source of Truthを確立し、詳細な説明は1つのファイルに集約
  - 他のファイルからは参照関係を明確にする（例: 「詳細: `.cursor/rules/00-workflow-checklist.d/02-task-start.md`を参照」）
  - 将来的なメンテナンス性を考慮し、ファイルの統合や参照構成を検討
  - 例:
    ```markdown
    # ❌ 悪い例: 同じ内容が複数のファイルに重複
    # ファイルA
    - **必須**: チケット開始時には必ずステータスを「In Progress」に変更すること
    
    # ファイルB
    - **必須**: チケット開始時には必ずステータスを「In Progress」に変更すること
    
    # ✅ 良い例: 詳細は1つのファイルに集約し、他から参照
    # ファイルA（詳細）
    - **🚨 CRITICAL: 必ずステータスを「In Progress」に変更**
      - チケット開始時には必ずステータスを「In Progress」に変更すること
      - ステータス変更に失敗した場合は警告を表示するが、作業は継続可能
    
    # ファイルB（参照）
    - **🚨 CRITICAL: 必ずステータスを「In Progress」に変更**
      - **詳細**: ファイルAの「🚨 CRITICAL: 必ずステータスを「In Progress」に変更」を参照
    ```

**一時ファイルの安全な取り扱い**
- **指摘**: 一時ファイルのクリーンアップ処理がない、または`/tmp`に直接ファイルを作成している
- **対応**:
  - `mktemp`または`mktemp -d`を使用して一時ファイル/ディレクトリを作成
  - `trap`を使用してスクリプト終了時にクリーンアップ処理を実行
  - 例:
    ```bash
    # 一時ディレクトリを作成
    TEMP_DIR=$(mktemp -d -t "script-name-XXXXXX" 2>/dev/null || mktemp -d)

    # クリーンアップ関数
    cleanup_temp_files() {
        if [ -n "${TEMP_DIR:-}" ] && [ -d "$TEMP_DIR" ]; then
            rm -rf "$TEMP_DIR"
        fi
    }

    # スクリプト終了時にクリーンアップ
    trap cleanup_temp_files EXIT INT TERM
    ```

**スクリプト間の連携方法の改善**
- **指摘**: スクリプト間の連携でエラーハンドリングや戻り値の処理が不十分
- **対応**:
  - 呼び出し元で終了コードを確認し、適切にエラーハンドリングを行う
  - エラーが発生しても続行可能な場合は、エラーを記録しつつ処理を継続
  - 例:
    ```bash
    OUTPUT=$(bash "${SCRIPT_PATH}" "$arg1" "$arg2" 2>&1)
    EXIT_CODE=$?

    if [ $EXIT_CODE -eq 0 ]; then
        echo "✅ 成功"
    else
        echo "❌ 失敗 (終了コード: ${EXIT_CODE})"
        echo "$OUTPUT" | grep -E "(エラー|error|Error)" | head -3
        # エラーが発生しても続行可能な場合は、ここで処理を継続
    fi
    ```

**エラーハンドリングの明確化**
- **指摘**: エラーハンドリングが一貫していない、または不十分
- **対応**:
  - すべてのスクリプトで`set -e`を使用（エラー時に即座に終了）
  - `handle_jira_error`などの共通エラーハンドリング関数を使用
  - エラーメッセージは明確で、対処方法が分かるようにする
  - エラー発生時は適切な終了コードを返す（0: 成功、1以上: エラー）

#### 対応例

```bash
# 1. レビューコメントを確認
gh pr view 21 --json reviews

# 2. ToDoリストを作成
# (todo_writeツールを使用)

# 3. 各指摘に対応
# - 設定の重複問題を解決
git add config/projects/mrwebdefence-design.yaml scripts/jira/config.sh
git commit -m "fix: Geminiレビュー指摘に対応 - 設定の重複問題を解決"

# 4. 対応完了をPRコメントで報告
gh pr comment 21 --body "## ✅ Geminiレビュー指摘への対応完了

以下の指摘に対応しました:

1. **設定の重複問題**
   - config/projects/*.yamlをSingle Source of Truthとして使用
   - config.shを修正し、YAMLファイルから設定を読み込むように変更

2. **ドキュメントの明確化**
   - JIRA_SETUP.mdに設定の優先順位を追加
   - Single Source of Truthの説明を追加

3. **YAML設定ファイルの改善**
   - コメントを追加し、構造を明確化

すべての指摘に対応しました。レビューをお願いします。"
```
